#include <iostream>
#include <argparse/argparse.hpp>
#include "Util.hpp"
#include "Program.hpp"
#include "Lexer.hpp"
#include "Parser.hpp"
#include "CodeGen.hpp"
#include "Interpreter.hpp"

auto SetupArgParse() -> argparse::ArgumentParser {
	auto program = argparse::ArgumentParser("LuNI Interpreter");
	program.add_argument("inputs")
		.required();
	program.add_argument("--verbose-lexing")
		.help("Output lexing logs along with errors")
		.default_value(false)
		.implicit_value(true);
	program.add_argument("--verbose-parsing")
		.help("Output parsing logs along with errors")
		.default_value(false)
		.implicit_value(true);
	program.add_argument("-b", "--run-bytecode")
		.help("Run the files as bytecode generated by LuNI instead of run them as Lua source code")
		.default_value(false)
		.implicit_value(true);
	program.add_argument("-p", "--output-bytecode")
		.help("Output the generated bytecode to a file named <input-file-name>.luni_bytecode (.lua suffix will be kept if present)")
		.default_value(false)
		.implicit_value(true);
	return program;
}

auto ProgramFromSource(
		std::string_view path,
		LuNI::Lexer lexer,
		LuNI::Parser parser,
		LuNI::CodeGen codeGen
) -> LuNI::BytecodeProgram {
	// TODO
}

auto ProgramFromInput(std::string_view path) -> LuNI::BytecodeProgram {
	// TODO
}

int main(int argc, char* argv[]) {
	auto program = SetupArgParse();
	try {
		program.parse_args(argc, argv);
	} catch (const std::runtime_error& err) {
		std::cout << err.what() << '\n';
		std::cout << program;
		return -1;
	}

	LuNI::Lexer lexer(&program);
	LuNI::Parser parser(&program);
	LuNI::CodeGen codeGen(&program);

	auto inputBytecode = program["--run-bytecode"] == true;
	auto inputs = program.get<std::vector<std::string>>("inputs");
	for (const auto& input : inputs) {
		auto program = inputBytecode
			? ProgramFromSource(input, lexer, parser, codeGen)
			: ProgramFromInput(input);
		 LuNI::Interpreter interpreter(program);
		 interpreter.Run();
	}

	return 0;
}
